## 如果一个节点断联会发生什么
### 断联的含义
一个节点与集群其他节点断开，网络不可达，但是自身仍然存活，不等同于机器故障。cfg.disconnect
### 如果是主结点断联并且重连
主节点断联，其任期不会递增，但是会不断试图往它认为的两个从节点发送不可达的心跳，同时刷新自己的选举定时器 （因为断联形成网络分区），等主结点重连后，其作为从节点任期会被更新
### 从节点断联并且重连
重连后有两种解决方法：
* leader的自我否定
* 通过重连后的从节点开启选举来更新自己的任期
### 断联节点重连后是否需要回应leader节点发送的心跳？
* 回应：
  * 因为节点断联期间term不断增大，比leader大，那么重连后应该在整个集群内重新选举，那么leader是怎么直到重新选举的呢？利用了包含节点term的心跳响应结构体，当从节点重连后会收到 leader发送过来的心跳，然后会尝试向leader响应自己的任期，leader检查响应体发现比自己的任期大，则会更新自己的任期并且转换为从节点，随后等待集群中 的某一个节点选举超时重新发起投票
* 不回应：
  * 不回应表明重连后的从节点只拒绝了leader的心跳，随后从节点在超过时间后就会主动发起新一轮选举，如果发现从节点log和自己一样新则会投票，否则将自己状态变为follower，等下一轮选举超时时间
## Lab2A-Leader Election
### 从节点响应主结点RequestVote RPC的时候，每次都应该返回最新的任期吗？
如果主节点的任期比自己的大，从节点收到RequestVote RPC后会更新自己的任期， 此时我们需要将更新后的任期返回给主节点，主结点拿到的响应后，会比较当前的任期 和该节点的任期是否一致，如果不一致则该票是无效的，因为在一个任期内的请求和对应的响应 rpc的任期是应该相同的情况下，票才有效
### 为什么要排除无效票？
旧任期时产生的投票称为无效票，无效票可能在当前新一轮leader选举时导致产生两个 leader。例子，三个节点ABC，任期为9时节点A率先发起选举， 因为网络原因，从节点B和C的响应rpc都没有送到目的实例， 在任期等于10的时候，节点B、A先后发起拉票，B节点收到了C节点的投票后成为了leader， 与此同时节点A收到了任期9时产生的B和C节点的同意投票rpc，如果A不做比较 该投票是旧任期还是新任期，此时A认为自己可以成为leader， 此时集群中有两个leader。
## leader election的大概实现流程
### 创建三个raft实例并且分别初始化
1.初始化信息：自己的实例编号，对等节点数组，term=0，voteFor=-1，state=Follower。\
2.启动时设置心跳周期（每秒不超10次）和选举定时器（300ms-600ms），这样能保证在结点数足够的情况下一次选举周期内大概率能选出一个Leader。\
3.为每个Raft实例开启一个ticker协程，用于超时选举以及发送心跳，每过50毫秒会被唤醒一次，主要用来判断节点的状态，并且做出相应的反馈，如果当前节点为Follower节点或者Candidate且该节点的选举定时器过期，则重置并且试图发起一次选举操作，如果该节点是Leader节点，则会进行一次判断该leader节点的心跳定时器是否过期，如果是就续期操作， 这个时候会发送一个空的AppendEntries给所属的从节点。\
4.选举流程：
* 发送端：发出RequestVote RPC前将自己设置为Candidate，重置自己的选举定时器、Term自增以及给自己投一票，然后开始拉取选票，这个会遍历自己的对等节点数组，并且会开启对等节点数量的协程。如果票数大于总结点数的一半，那么就可以认为自己是leader并且迅速发送一个空数据的 AppendEntries给所有的从节点，其他的从节点收到了Term大于自己的心跳就认为这个Leader合法，同时执行一些更新操作，包括将自己转变为Follower状态，更新自己的Term。
* 接收端：如果发现发送端的Term小于自己，拒绝。同时将投票结果给Candidate，反之赞成，重置选举计时器和更新Term
5.心跳流程
* 发送端：只有Leader节点能发送，在一个节点首次由Candidate成为Leader后会立即发送一个心跳给对等节点。
* 接收到Leader节点的心跳后，会比较两个任期，如果Leader的任期小于自己的则直接丢弃并且响应false，如果大于等于则更新自己的任期，重置自己的状态为Follower，同时重置选举定时器，将自己的的投票状态设置为-1。